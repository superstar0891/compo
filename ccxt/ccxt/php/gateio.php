<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\ArgumentsRequired;

class gateio extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'gateio',
            'name' => 'Gate.io',
            'country' => array( 'KR' ),
            'rateLimit' => 1000,
            'version' => '4',
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/31784029-0313c702-b509-11e7-9ccc-bc0da6a0e435.jpg',
                'doc' => 'https://www.gate.io/docs/apiv4/en/index.html',
                'www' => 'https://gate.io/',
                'api' => array(
                    'public' => 'https://api.gateio.ws/api/v4',
                    'private' => 'https://api.gateio.ws/api/v4',
                ),
            ),
            'has' => array(
                'fetchMarkets' => true,
                'fetchCurrencies' => true,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTrades' => true,
                'fetchMyTrades' => true,
                'fetchBalance' => true,
                'fetchOpenOrders' => true,
                'fetchClosedOrders' => true,
                'fetchOrder' => true,
                'createOrder' => true,
                'cancelOrder' => true,
                'withdraw' => true,
                'fetchDeposits' => true,
                'fetchWithdrawals' => true,
                'transfer' => true,
            ),
            'api' => array(
                'public' => array(
                    'spot' => array(
                        'get' => array(
                            'currencies',
                            'currencies/{currency}',
                            'currency_pairs',
                            'currency_pairs/{currency_pair}',
                            'tickers',
                            'order_book',
                            'trades',
                            'candlesticks',
                        ),
                    ),
                    'margin' => array(
                        'get' => array(
                            'currency_pairs',
                            'currency_pairs/{currency_pair}',
                            'cross/currencies',
                            'cross/currencies/{currency}',
                        ),
                    ),
                    'futures' => array(
                        'get' => array(
                            '{settle}/contracts',
                            '{settle}/contracts/{contract}',
                            '{settle}/order_book',
                            '{settle}/trades',
                            '{settle}/candlesticks',
                            '{settle}/tickers',
                            '{settle}/funding_rate',
                            '{settle}/insurance',
                            '{settle}/contract_stats',
                            '{settle}/liq_orders',
                        ),
                    ),
                    'delivery' => array(
                        'get' => array(
                            '{settle}/contracts',
                            '{settle}/contracts/{contract}',
                            '{settle}/order_book',
                            '{settle}/trades',
                            '{settle}/candlesticks',
                            '{settle}/tickers',
                            '{settle}/insurance',
                        ),
                    ),
                ),
                'private' => array(
                    'withdrawals' => array(
                        'post' => array(
                            '', // /withdrawals
                        ),
                        'delete' => array(
                            '{withdrawal_id}',
                        ),
                    ),
                    'wallet' => array(
                        'get' => array(
                            'deposit_address',
                            'withdrawals',
                            'deposits',
                            'sub_account_transfers',
                            'withdraw_status',
                            'sub_account_balances',
                            'fee',
                        ),
                        'post' => array(
                            'transfers',
                            'sub_account_transfers',
                        ),
                    ),
                    'spot' => array(
                        'get' => array(
                            'accounts',
                            'open_orders',
                            'orders',
                            'orders/{order_id}',
                            'my_trades',
                            'price_orders',
                            'price_orders/{order_id}',
                        ),
                        'post' => array(
                            'batch_orders',
                            'orders',
                            'cancel_batch_orders',
                            'price_orders',
                        ),
                        'delete' => array(
                            'orders',
                            'orders/{order_id}',
                            'price_orders',
                            'price_orders/{order_id}',
                        ),
                    ),
                    'margin' => array(
                        'get' => array(
                            'account_book',
                            'funding_accounts',
                            'loans',
                            'loans/{loan_id}',
                            'loans/{loan_id}/repayment',
                            'loan_records',
                            'loan_records/{load_record_id}',
                            'auto_repay',
                            'transferable',
                            'cross/accounts',
                            'cross/account_book',
                            'cross/loans',
                            'cross/loans/{loan_id}',
                            'cross/loans/repayments',
                            'cross/transferable',
                        ),
                        'post' => array(
                            'loans',
                            'merged_loans',
                            'loans/{loan_id}/repayment',
                            'auto_repay',
                            'cross/loans',
                            'cross/loans/repayments',
                        ),
                        'patch' => array(
                            'loans/{loan_id}',
                            'loan_records/{loan_record_id}',
                        ),
                        'delete' => array(
                            'loans/{loan_id}',
                        ),
                    ),
                    'futures' => array(
                        'get' => array(
                            '{settle}/accounts',
                            '{settle}/account_book',
                            '{settle}/positions',
                            '{settle}/positions/{contract}',
                            '{settle}/orders',
                            '{settle}/orders/{order_id}',
                            '{settle}/my_trades',
                            '{settle}/position_close',
                            '{settle}/liquidates',
                            '{settle}/price_orders',
                            '{settle}/price_orders/{order_id}',
                        ),
                        'post' => array(
                            '{settle}/positions/{contract}/margin',
                            '{settle}/positions/{contract}/leverage',
                            '{settle}/positions/{contract}/risk_limit',
                            '{settle}/dual_mode',
                            '{settle}/dual_comp/positions/{contract}',
                            '{settle}/dual_comp/positions/{contract}/margin',
                            '{settle}/dual_comp/positions/{contract}/leverage',
                            '{settle}/dual_comp/positions/{contract}/risk_limit',
                            '{settle}/orders',
                            '{settle}/price_orders',
                        ),
                        'delete' => array(
                            '{settle}/orders',
                            '{settle}/orders/{order_id}',
                            '{settle}/price_orders',
                            '{settle}/price_orders/{order_id}',
                        ),
                    ),
                    'delivery' => array(
                        'get' => array(
                            '{settle}/accounts',
                            '{settle}/account_book',
                            '{settle}/positions',
                            '{settle}/positions/{contract}',
                            '{settle}/orders',
                            '{settle}/orders/{order_id}',
                            '{settle}/my_trades',
                            '{settle}/position_close',
                            '{settle}/liquidates',
                            '{settle}/price_orders',
                            '{settle}/price_orders/{order_id}',
                        ),
                        'post' => array(
                            '{settle}/positions/{contract}/margin',
                            '{settle}/positions/{contract}/leverage',
                            '{settle}/positions/{contract}/risk_limit',
                            '{settle}/orders',
                        ),
                        'delete' => array(
                            '{settle}/orders',
                            '{settle}/orders/{order_id}',
                            '{settle}/price_orders',
                            '{settle}/price_orders/{order_id}',
                        ),
                    ),
                ),
            ),
            'timeframes' => array(
                '10s' => '10s',
                '1m' => '1m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '4h' => '4h',
                '8h' => '8h',
                '1d' => '1d',
                '7d' => '7d',
            ),
            // copied from gateiov2
            'commonCurrencies' => array(
                '88MPH' => 'MPH',
                'BIFI' => 'Bitcoin File',
                'BOX' => 'DefiBox',
                'BTCBEAR' => 'BEAR',
                'BTCBULL' => 'BULL',
                'BYN' => 'Beyond Finance',
                'GTC' => 'Game.com', // conflict with Gitcoin and Gastrocoin
                'GTC_HT' => 'Game.com HT',
                'GTC_BSC' => 'Game.com BSC',
                'HIT' => 'HitChain',
                'MPH' => 'Morpher', // conflict with 88MPH
                'RAI' => 'Rai Reflex Index', // conflict with RAI Finance
                'SBTC' => 'Super Bitcoin',
                'TNC' => 'Trinity Network Credit',
                'VAI' => 'VAIOT',
            ),
            'options' => array(
                'accountsByType' => array(
                    'spot' => 'spot',
                    'margin' => 'margin',
                    'futures' => 'futures',
                    'delivery' => 'delivery',
                ),
            ),
            // https://www.gate.io/docs/apiv4/en/index.html#label-list
            'exceptions' => array(
                'INVALID_PARAM_VALUE' => '\\ccxt\\BadRequest',
                'INVALID_PROTOCOL' => '\\ccxt\\BadRequest',
                'INVALID_ARGUMENT' => '\\ccxt\\BadRequest',
                'INVALID_REQUEST_BODY' => '\\ccxt\\BadRequest',
                'MISSING_REQUIRED_PARAM' => '\\ccxt\\ArgumentsRequired',
                'BAD_REQUEST' => '\\ccxt\\BadRequest',
                'INVALID_CONTENT_TYPE' => '\\ccxt\\BadRequest',
                'NOT_ACCEPTABLE' => '\\ccxt\\BadRequest',
                'METHOD_NOT_ALLOWED' => '\\ccxt\\BadRequest',
                'NOT_FOUND' => '\\ccxt\\ExchangeError',
                'INVALID_CREDENTIALS' => '\\ccxt\\AuthenticationError',
                'INVALID_KEY' => '\\ccxt\\AuthenticationError',
                'IP_FORBIDDEN' => '\\ccxt\\AuthenticationError',
                'READ_ONLY' => '\\ccxt\\PermissionDenied',
                'INVALID_SIGNATURE' => '\\ccxt\\AuthenticationError',
                'MISSING_REQUIRED_HEADER' => '\\ccxt\\AuthenticationError',
                'REQUEST_EXPIRED' => '\\ccxt\\AuthenticationError',
                'ACCOUNT_LOCKED' => '\\ccxt\\AccountSuspended',
                'FORBIDDEN' => '\\ccxt\\PermissionDenied',
                'SUB_ACCOUNT_NOT_FOUND' => '\\ccxt\\ExchangeError',
                'SUB_ACCOUNT_LOCKED' => '\\ccxt\\AccountSuspended',
                'MARGIN_BALANCE_EXCEPTION' => '\\ccxt\\ExchangeError',
                'MARGIN_TRANSFER_FAILED' => '\\ccxt\\ExchangeError',
                'TOO_MUCH_FUTURES_AVAILABLE' => '\\ccxt\\ExchangeError',
                'FUTURES_BALANCE_NOT_ENOUGH' => '\\ccxt\\InsufficientFunds',
                'ACCOUNT_EXCEPTION' => '\\ccxt\\ExchangeError',
                'SUB_ACCOUNT_TRANSFER_FAILED' => '\\ccxt\\ExchangeError',
                'ADDRESS_NOT_USED' => '\\ccxt\\ExchangeError',
                'TOO_FAST' => '\\ccxt\\RateLimitExceeded',
                'WITHDRAWAL_OVER_LIMIT' => '\\ccxt\\ExchangeError',
                'API_WITHDRAW_DISABLED' => '\\ccxt\\ExchangeNotAvailable',
                'INVALID_WITHDRAW_ID' => '\\ccxt\\ExchangeError',
                'INVALID_WITHDRAW_CANCEL_STATUS' => '\\ccxt\\ExchangeError',
                'INVALID_PRECISION' => '\\ccxt\\InvalidOrder',
                'INVALID_CURRENCY' => '\\ccxt\\BadSymbol',
                'INVALID_CURRENCY_PAIR' => '\\ccxt\\BadSymbol',
                'POC_FILL_IMMEDIATELY' => '\\ccxt\\ExchangeError',
                'ORDER_NOT_FOUND' => '\\ccxt\\OrderNotFound',
                'ORDER_CLOSED' => '\\ccxt\\InvalidOrder',
                'ORDER_CANCELLED' => '\\ccxt\\InvalidOrder',
                'QUANTITY_NOT_ENOUGH' => '\\ccxt\\InvalidOrder',
                'BALANCE_NOT_ENOUGH' => '\\ccxt\\InsufficientFunds',
                'MARGIN_NOT_SUPPORTED' => '\\ccxt\\InvalidOrder',
                'MARGIN_BALANCE_NOT_ENOUGH' => '\\ccxt\\InsufficientFunds',
                'AMOUNT_TOO_LITTLE' => '\\ccxt\\InvalidOrder',
                'AMOUNT_TOO_MUCH' => '\\ccxt\\InvalidOrder',
                'REPEATED_CREATION' => '\\ccxt\\InvalidOrder',
                'LOAN_NOT_FOUND' => '\\ccxt\\OrderNotFound',
                'LOAN_RECORD_NOT_FOUND' => '\\ccxt\\OrderNotFound',
                'NO_MATCHED_LOAN' => '\\ccxt\\ExchangeError',
                'NOT_MERGEABLE' => '\\ccxt\\ExchangeError',
                'NO_CHANGE' => '\\ccxt\\ExchangeError',
                'REPAY_TOO_MUCH' => '\\ccxt\\ExchangeError',
                'TOO_MANY_CURRENCY_PAIRS' => '\\ccxt\\InvalidOrder',
                'TOO_MANY_ORDERS' => '\\ccxt\\InvalidOrder',
                'MIXED_ACCOUNT_TYPE' => '\\ccxt\\InvalidOrder',
                'AUTO_BORROW_TOO_MUCH' => '\\ccxt\\ExchangeError',
                'TRADE_RESTRICTED' => '\\ccxt\\InsufficientFunds',
                'USER_NOT_FOUND' => '\\ccxt\\ExchangeError',
                'CONTRACT_NO_COUNTER' => '\\ccxt\\ExchangeError',
                'CONTRACT_NOT_FOUND' => '\\ccxt\\BadSymbol',
                'RISK_LIMIT_EXCEEDED' => '\\ccxt\\ExchangeError',
                'INSUFFICIENT_AVAILABLE' => '\\ccxt\\InsufficientFunds',
                'LIQUIDATE_IMMEDIATELY' => '\\ccxt\\InvalidOrder',
                'LEVERAGE_TOO_HIGH' => '\\ccxt\\InvalidOrder',
                'LEVERAGE_TOO_LOW' => '\\ccxt\\InvalidOrder',
                'ORDER_NOT_OWNED' => '\\ccxt\\ExchangeError',
                'ORDER_FINISHED' => '\\ccxt\\ExchangeError',
                'POSITION_CROSS_MARGIN' => '\\ccxt\\ExchangeError',
                'POSITION_IN_LIQUIDATION' => '\\ccxt\\ExchangeError',
                'POSITION_IN_CLOSE' => '\\ccxt\\ExchangeError',
                'POSITION_EMPTY' => '\\ccxt\\InvalidOrder',
                'REMOVE_TOO_MUCH' => '\\ccxt\\ExchangeError',
                'RISK_LIMIT_NOT_MULTIPLE' => '\\ccxt\\ExchangeError',
                'RISK_LIMIT_TOO_HIGH' => '\\ccxt\\ExchangeError',
                'RISK_LIMIT_TOO_lOW' => '\\ccxt\\ExchangeError',
                'PRICE_TOO_DEVIATED' => '\\ccxt\\InvalidOrder',
                'SIZE_TOO_LARGE' => '\\ccxt\\InvalidOrder',
                'SIZE_TOO_SMALL' => '\\ccxt\\InvalidOrder',
                'PRICE_OVER_LIQUIDATION' => '\\ccxt\\InvalidOrder',
                'PRICE_OVER_BANKRUPT' => '\\ccxt\\InvalidOrder',
                'ORDER_POC_IMMEDIATE' => '\\ccxt\\InvalidOrder',
                'INCREASE_POSITION' => '\\ccxt\\InvalidOrder',
                'CONTRACT_IN_DELISTING' => '\\ccxt\\ExchangeError',
                'INTERNAL' => '\\ccxt\\ExchangeError',
                'SERVER_ERROR' => '\\ccxt\\ExchangeError',
                'TOO_BUSY' => '\\ccxt\\ExchangeNotAvailable',
            ),
        ));
    }

    public function fetch_markets($params = array ()) {
        $response = $this->publicSpotGetCurrencyPairs ($params);
        //
        //     {
        //       "$id" => "DEGO_USDT",
        //       "$base" => "DEGO",
        //       "$quote" => "USDT",
        //       "fee" => "0.2",
        //       "min_quote_amount" => "1",
        //       "amount_precision" => "4",
        //       "$precision" => "4",
        //       "trade_status" => "tradable",
        //       "sell_start" => "0",
        //       "buy_start" => "0"
        //     }
        //
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $entry = $response[$i];
            $id = $this->safe_string($entry, 'id');
            $baseId = $this->safe_string($entry, 'base');
            $quoteId = $this->safe_string($entry, 'quote');
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $symbol = $base . '/' . $quote;
            $taker = $this->safe_number($entry, 'fee');
            $maker = null;
            $tradeStatus = $this->safe_string($entry, 'trade_status');
            $active = $tradeStatus === 'tradable';
            $amountPrecision = $this->safe_string($entry, 'amount_precision');
            $pricePrecision = $this->safe_string($entry, 'precision');
            $amountLimit = $this->parse_precision($amountPrecision);
            $priceLimit = $this->parse_precision($pricePrecision);
            $limits = array(
                'amount' => array(
                    'min' => $this->parse_number($amountLimit),
                    'max' => null,
                ),
                'price' => array(
                    'min' => $this->parse_number($priceLimit),
                    'max' => null,
                ),
                'cost' => array(
                    'min' => $this->safe_number($entry, 'min_quote_amount'),
                    'max' => null,
                ),
            );
            $precision = array(
                'amount' => intval($amountPrecision),
                'price' => intval($pricePrecision),
            );
            $result[] = array(
                'info' => $entry,
                'id' => $id,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'base' => $base,
                'quote' => $quote,
                'symbol' => $symbol,
                'limits' => $limits,
                'precision' => $precision,
                'active' => $active,
                'maker' => $maker,
                'taker' => $taker,
            );
        }
        return $result;
    }

    public function fetch_currencies($params = array ()) {
        $response = $this->publicSpotGetCurrencies ($params);
        //
        //     {
        //       "currency" => "BCN",
        //       "$delisted" => false,
        //       "$withdraw_disabled" => true,
        //       "withdraw_delayed" => false,
        //       "$deposit_disabled" => true,
        //       "$trade_disabled" => false
        //     }
        //
        $result = array();
        // TODO => remove magic constants
        $amountPrecision = 6;
        for ($i = 0; $i < count($response); $i++) {
            $entry = $response[$i];
            $currencyId = $this->safe_string($entry, 'currency');
            $code = $this->safe_currency_code($currencyId);
            $delisted = $this->safe_value($entry, 'delisted');
            $withdraw_disabled = $this->safe_value($entry, 'withdraw_disabled');
            $deposit_disabled = $this->safe_value($entry, 'disabled_disabled');
            $trade_disabled = $this->safe_value($entry, 'trade_disabled');
            $active = !($delisted && $withdraw_disabled && $deposit_disabled && $trade_disabled);
            $result[$code] = array(
                'id' => $currencyId,
                'name' => null,
                'code' => $code,
                'precision' => array(
                    'amount' => $amountPrecision,
                    'price' => null,
                ),
                'info' => $entry,
                'active' => $active,
                'fee' => null,
                'fees' => array(),
                'limits' => $this->limits,
            );
        }
        return $result;
    }

    public function fetch_network_deposit_address($code, $params = array ()) {
        $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'currency' => $currency['id'],
        );
        $response = $this->privateWalletGetDepositAddress (array_merge($request, $params));
        $addresses = $this->safe_value($response, 'multichain_addresses');
        $currencyId = $this->safe_string($response, 'currency');
        $code = $this->safe_currency_code($currencyId);
        $result = array();
        for ($i = 0; $i < count($addresses); $i++) {
            $entry = $addresses[$i];
            //
            //     {
            //       "chain" => "ETH",
            //       "$address" => "0x359a697945E79C7e17b634675BD73B33324E9408",
            //       "payment_id" => "",
            //       "payment_name" => "",
            //       "obtain_failed" => "0"
            //     }
            //
            $obtainFailed = $this->safe_integer($entry, 'obtain_failed');
            if ($obtainFailed) {
                continue;
            }
            $network = $this->safe_string($entry, 'chain');
            $address = $this->safe_string($entry, 'address');
            $tag = $this->safe_string($entry, 'payment_id');
            $tagLength = is_array($tag) ? count($tag) : 0;
            $tag = $tagLength ? $tag : null;
            $result[$network] = array(
                'info' => $entry,
                'code' => $code,
                'address' => $address,
                'tag' => $tag,
            );
        }
        return $result;
    }

    public function fetch_deposit_address($code, $params = array ()) {
        $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'currency' => $currency['id'],
        );
        $response = $this->privateWalletGetDepositAddress (array_merge($request, $params));
        //
        //     {
        //       "$currency" => "XRP",
        //       "$address" => "rHcFoo6a9qT5NHiVn1THQRhsEGcxtYCV4d 391331007",
        //       "multichain_addresses" => array(
        //         {
        //           "chain" => "XRP",
        //           "$address" => "rHcFoo6a9qT5NHiVn1THQRhsEGcxtYCV4d",
        //           "payment_id" => "391331007",
        //           "payment_name" => "Tag",
        //           "obtain_failed" => 0
        //         }
        //       )
        //     }
        //
        $currencyId = $this->safe_string($response, 'currency');
        $code = $this->safe_currency_code($currencyId);
        $addressField = $this->safe_string($response, 'address');
        $tag = null;
        $address = null;
        if (mb_strpos($addressField, ' ') > -1) {
            $splitted = explode(' ', $addressField);
            $address = $splitted[0];
            $tag = $splitted[1];
        } else {
            $address = $addressField;
        }
        return array(
            'info' => $response,
            'code' => $code,
            'address' => $address,
            'tag' => $tag,
        );
    }

    public function fetch_trading_fees($params = array ()) {
        $this->load_markets();
        $response = $this->privateWalletGetFee ($params);
        //
        //     {
        //       "user_id" => 1486602,
        //       "taker_fee" => "0.002",
        //       "maker_fee" => "0.002",
        //       "gt_discount" => true,
        //       "gt_taker_fee" => "0.0015",
        //       "gt_maker_fee" => "0.0015",
        //       "loan_fee" => "0.18",
        //       "point_type" => "0",
        //       "futures_taker_fee" => "0.0005",
        //       "futures_maker_fee" => "0"
        //     }
        //
        $result = array();
        $taker = $this->safe_number($response, 'taker_fee');
        $maker = $this->safe_number($response, 'maker_fee');
        for ($i = 0; $i < count($this->symbols); $i++) {
            $symbol = $this->symbols[$i];
            $result[$symbol] = array(
                'maker' => $maker,
                'taker' => $taker,
                'info' => $response,
                'symbol' => $symbol,
            );
        }
        return $result;
    }

    public function fetch_funding_fees($params = array ()) {
        $this->load_markets();
        $response = $this->privateWalletGetWithdrawStatus ($params);
        //
        //     {
        //       "currency" => "MTN",
        //       "name" => "Medicalchain",
        //       "name_cn" => "Medicalchain",
        //       "deposit" => "0",
        //       "withdraw_percent" => "0%",
        //       "withdraw_fix" => "900",
        //       "withdraw_day_limit" => "500000",
        //       "withdraw_day_limit_remain" => "500000",
        //       "withdraw_amount_mini" => "900.1",
        //       "withdraw_eachtime_limit" => "90000000000",
        //       "withdraw_fix_on_chains" => {
        //         "ETH" => "900"
        //       }
        //     }
        //
        $withdrawFees = array();
        for ($i = 0; $i < count($response); $i++) {
            $entry = $response[$i];
            $currencyId = $this->safe_string($entry, 'currency');
            $code = $this->safe_currency_code($currencyId);
            $withdrawFees[$code] = array();
            $withdrawFix = $this->safe_value($entry, 'withdraw_fix_on_chains');
            if ($withdrawFix === null) {
                $withdrawFix = array();
                $withdrawFix[$code] = $this->safe_number($entry, 'withdraw_fix');
            }
            $keys = is_array($withdrawFix) ? array_keys($withdrawFix) : array();
            for ($i = 0; $i < count($keys); $i++) {
                $key = $keys[$i];
                $withdrawFees[$code][$key] = $this->parse_number($withdrawFix[$key]);
            }
        }
        return array(
            'info' => $response,
            'withdraw' => $withdrawFees,
            'deposit' => array(),
        );
    }

    public function fetch_order_book($symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'currency_pair' => $market['id'],
        );
        $response = $this->publicSpotGetOrderBook (array_merge($request, $params));
        $timestamp = $this->safe_integer($response, 'current');
        return $this->parse_order_book($response, $symbol, $timestamp);
    }

    public function fetch_ticker($symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'currency_pair' => $market['id'],
        );
        $response = $this->publicSpotGetTickers (array_merge($request, $params));
        $ticker = $this->safe_value($response, 0);
        return $this->parse_ticker($ticker, $market);
    }

    public function parse_ticker($ticker, $market = null) {
        //
        //     {
        //       "currency_pair" => "KFC_USDT",
        //       "$last" => "7.255",
        //       "lowest_ask" => "7.298",
        //       "highest_bid" => "7.218",
        //       "change_percentage" => "-1.18",
        //       "base_volume" => "1219.053687865",
        //       "quote_volume" => "8807.40299875455",
        //       "high_24h" => "7.262",
        //       "low_24h" => "7.095"
        //     }
        //
        $marketId = $this->safe_string($ticker, 'currency_pair');
        $symbol = $this->safe_symbol($marketId, $market);
        $last = $this->safe_number($ticker, 'last');
        $ask = $this->safe_number($ticker, 'lowest_ask');
        $bid = $this->safe_number($ticker, 'highest_bid');
        $high = $this->safe_number($ticker, 'high_24h');
        $low = $this->safe_number($ticker, 'low_24h');
        $baseVolume = $this->safe_number($ticker, 'base_volume');
        $quoteVolume = $this->safe_number($ticker, 'quote_volume');
        $percentage = $this->safe_number($ticker, 'change_percentage');
        return array(
            'symbol' => $symbol,
            'timestamp' => null,
            'datetime' => null,
            'high' => $high,
            'low' => $low,
            'bid' => $bid,
            'bidVolume' => null,
            'ask' => $ask,
            'askVolume' => null,
            'vwap' => null,
            'open' => null,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => $percentage,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        );
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        $this->load_markets();
        $response = $this->publicSpotGetTickers ($params);
        $ticker = $this->safe_value($response, 0);
        return $this->parse_tickers($ticker, $symbols);
    }

    public function fetch_balance($params = array ()) {
        $this->load_markets();
        $response = $this->privateSpotGetAccounts ($params);
        //
        //     array(
        //       array(
        //         "currency" => "DBC",
        //         "available" => "0",
        //         "locked" => "0"
        //       ),
        //       ...
        //     )
        //
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $entry = $response[$i];
            $account = $this->account();
            $currencyId = $this->safe_string($entry, 'currency');
            $code = $this->safe_currency_code($currencyId);
            $account['used'] = $this->safe_string($entry, 'locked');
            $account['free'] = $this->safe_string($entry, 'available');
            $result[$code] = $account;
        }
        return $this->parse_balance($result);
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'currency_pair' => $market['id'],
            'interval' => $this->timeframes[$timeframe],
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        if ($since !== null) {
            $request['start'] = (int) floor($since / 1000);
        }
        $response = $this->publicSpotGetCandlesticks (array_merge($request, $params));
        return $this->parse_ohlcvs($response, $market, $timeframe, $since, $limit);
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        //
        //     array(
        //       "1626163200",           // Unix $timestamp in seconds
        //       "346711.933138181617",  // Trading $volume
        //       "33165.23",             // Close price
        //       "33260",                // Highest price
        //       "33117.6",              // Lowest price
        //       "33184.47"              // Open price
        //     )
        //
        $timestamp = $this->safe_timestamp($ohlcv, 0);
        $volume = $this->safe_number($ohlcv, 1);
        $close = $this->safe_number($ohlcv, 2);
        $high = $this->safe_number($ohlcv, 3);
        $low = $this->safe_number($ohlcv, 4);
        $open = $this->safe_number($ohlcv, 5);
        return array(
            $timestamp,
            $open,
            $high,
            $low,
            $close,
            $volume,
        );
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'currency_pair' => $market['id'],
        );
        $response = $this->publicSpotGetTrades (array_merge($request, $params));
        return $this->parse_trades($response, $market, $since, $limit);
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'currency_pair' => $market['id'],
        );
        $response = $this->privateSpotGetMyTrades (array_merge($request, $params));
        return $this->parse_trades($response, $market, $since, $limit);
    }

    public function parse_trade($trade, $market = null) {
        //
        // public
        //     {
        //       "$id" => "1334253759",
        //       "create_time" => "1626342738",
        //       "create_time_ms" => "1626342738331.497000",
        //       "currency_pair" => "BTC_USDT",
        //       "$side" => "sell",
        //       "$amount" => "0.0022",
        //       "$price" => "32452.16"
        //     }
        //
        // private
        //     {
        //       "$id" => "218087755",
        //       "create_time" => "1578958740",
        //       "create_time_ms" => "1578958740122.710000",
        //       "currency_pair" => "BTC_USDT",
        //       "$side" => "sell",
        //       "role" => "taker",
        //       "$amount" => "0.0004",
        //       "$price" => "8112.77",
        //       "order_id" => "8445563839",
        //       "$fee" => "0.006490216",
        //       "fee_currency" => "USDT",
        //       "point_fee" => "0",
        //       "gt_fee" => "0"
        //     }
        //
        $id = $this->safe_string($trade, 'id');
        $timestampString = $this->safe_string($trade, 'create_time_ms');
        $timestamp = null;
        if (mb_strpos($timestampString, '.') > 0) {
            $milliseconds = explode('.', $timestampString);
            $timestamp = intval($milliseconds[0]);
        }
        $marketId = $this->safe_string($trade, 'currency_pair');
        $symbol = $this->safe_symbol($marketId, $market);
        $amountString = $this->safe_string($trade, 'amount');
        $priceString = $this->safe_string($trade, 'price');
        $cost = $this->parse_number(Precise::string_mul($amountString, $priceString));
        $amount = $this->parse_number($amountString);
        $price = $this->parse_number($priceString);
        $side = $this->safe_string($trade, 'side');
        $orderId = $this->safe_string($trade, 'order_id');
        $gtFee = $this->safe_string($trade, 'gt_fee');
        $feeCurrency = null;
        $feeCost = null;
        if ($gtFee === '0') {
            $feeCurrency = $this->safe_string($trade, 'fee_currency');
            $feeCost = $this->safe_number($trade, 'fee');
        } else {
            $feeCurrency = 'GT';
            $feeCost = $this->parse_number($gtFee);
        }
        $fee = array(
            'cost' => $feeCost,
            'currency' => $feeCurrency,
        );
        $takerOrMaker = $this->safe_string($trade, 'role');
        return array(
            'info' => $trade,
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'order' => $orderId,
            'type' => null,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => $fee,
        );
    }

    public function fetch_deposits($code = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['currency'] = $currency['id'];
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        if ($since !== null) {
            $request['from'] = (int) floor($since / 1000);
        }
        $response = $this->privateWalletGetDeposits (array_merge($request, $params));
        return $this->parse_transactions($response, $currency);
    }

    public function fetch_withdrawals($code = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['currency'] = $currency['id'];
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        if ($since !== null) {
            $request['from'] = (int) floor($since / 1000);
        }
        $response = $this->privateWalletGetWithdrawals (array_merge($request, $params));
        return $this->parse_transactions($response, $currency);
    }

    public function withdraw($code, $amount, $address, $tag = null, $params = array ()) {
        $this->check_address($address);
        $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'currency' => $currency['id'],
            'address' => $address,
            'amount' => $this->currency_to_precision($code, $amount),
        );
        if ($tag !== null) {
            $request['memo'] = $tag;
        }
        $response = $this->privateWithdrawalsPost (array_merge($request, $params));
        //
        //     {
        //       "$id" => "w13389675",
        //       "$currency" => "USDT",
        //       "$amount" => "50",
        //       "$address" => "TUu2rLFrmzUodiWfYki7QCNtv1akL682p1",
        //       "memo" => null
        //     }
        //
        $currencyId = $this->safe_string($response, 'currency');
        $id = $this->safe_string($response, 'id');
        return array(
            'info' => $response,
            'id' => $id,
            'code' => $this->safe_currency_code($currencyId),
            'amount' => $this->safe_number($response, 'amount'),
            'address' => $this->safe_string($response, 'address'),
            'tag' => $this->safe_string($response, 'memo'),
        );
    }

    public function parse_transaction_status($status) {
        $statuses = array(
            'PEND' => 'pending',
            'REQUEST' => 'pending',
            'DMOVE' => 'pending',
            'CANCEL' => 'failed',
            'DONE' => 'ok',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_transaction_type($type) {
        $types = array(
            'd' => 'deposit',
            'w' => 'withdrawal',
        );
        return $this->safe_string($types, $type, $type);
    }

    public function parse_transaction($transaction, $currency = null) {
        //
        // deposits
        //     {
        //       "$id" => "d33361395",
        //       "$currency" => "USDT_TRX",
        //       "$address" => "TErdnxenuLtXfnMafLbfappYdHtnXQ5U4z",
        //       "$amount" => "100",
        //       "$txid" => "ae9374de34e558562fe18cbb1bf9ab4d9eb8aa7669d65541c9fa2a532c1474a0",
        //       "$timestamp" => "1626345819",
        //       "$status" => "DONE",
        //       "memo" => ""
        //     }
        //
        // withdrawals
        $id = $this->safe_string($transaction, 'id');
        $type = null;
        if ($id !== null) {
            $type = $this->parse_transaction_type($id[0]);
        }
        $currencyId = $this->safe_string($transaction, 'currency');
        $code = $this->safe_currency_code($currencyId);
        $amount = $this->safe_number($transaction, 'amount');
        $txid = $this->safe_string($transaction, 'txid');
        $rawStatus = $this->safe_string($transaction, 'status');
        $status = $this->parse_transaction_status($rawStatus);
        $address = $this->safe_string($transaction, 'address');
        $fee = $this->safe_number($transaction, 'fee');
        $tag = $this->safe_string($transaction, 'memo');
        if ($tag === '') {
            $tag = null;
        }
        $timestamp = $this->safe_timestamp($transaction, 'timestamp');
        return array(
            'info' => $transaction,
            'id' => $id,
            'txid' => $txid,
            'currency' => $code,
            'amount' => $amount,
            'address' => $address,
            'tag' => $tag,
            'status' => $status,
            'type' => $type,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'fee' => $fee,
        );
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'currency_pair' => $market['id'],
            'amount' => $this->amount_to_precision($symbol, $amount),
            'price' => $this->price_to_precision($symbol, $price),
            'side' => $side,
        );
        $response = $this->privateSpotPostOrders (array_merge($request, $params));
        return $this->parse_order($response, $market);
    }

    public function parse_order($order, $market = null) {
        // createOrder
        //     {
        //       "$id" => "62364648575",
        //       "text" => "apiv4",
        //       "create_time" => "1626354834",
        //       "update_time" => "1626354834",
        //       "create_time_ms" => "1626354833544",
        //       "update_time_ms" => "1626354833544",
        //       "$status" => "open",
        //       "currency_pair" => "BTC_USDT",
        //       "$type" => "limit",
        //       "account" => "spot",
        //       "$side" => "buy",
        //       "$amount" => "0.0001",
        //       "$price" => "30000",
        //       "time_in_force" => "gtc",
        //       "iceberg" => "0",
        //       "left" => "0.0001",
        //       "fill_price" => "0",
        //       "filled_total" => "0",
        //       "fee" => "0",
        //       "fee_currency" => "BTC",
        //       "point_fee" => "0",
        //       "gt_fee" => "0",
        //       "gt_discount" => true,
        //       "rebated_fee" => "0",
        //       "rebated_fee_currency" => "USDT"
        //     }
        //
        $id = $this->safe_string($order, 'id');
        $marketId = $this->safe_string($order, 'currency_pair');
        $symbol = $this->safe_symbol($marketId, $market);
        $timestamp = $this->safe_integer($order, 'create_time_ms');
        $lastTradeTimestamp = $this->safe_integer($order, 'update_time_ms');
        $amount = $this->safe_number($order, 'amount');
        $price = $this->safe_number($order, 'price');
        $remaining = $this->safe_number($order, 'left');
        $cost = $this->safe_number($order, 'filled_total'); // same as filled_price
        $side = $this->safe_string($order, 'side');
        $type = $this->safe_string($order, 'type');
        // open, closed, cancelled - almost already ccxt unified!
        $status = $this->safe_string($order, 'status');
        if ($status === 'cancelled') {
            $status = 'canceled';
        }
        $timeInForce = $this->safe_string_upper($order, 'time_in_force');
        $fees = array();
        $fees[] = array(
            'currency' => 'GT',
            'cost' => $this->safe_number($order, 'gt_fee'),
        );
        $fees[] = array(
            'currency' => $this->safe_currency_code($this->safe_string($order, 'fee_currency')),
            'cost' => $this->safe_number($order, 'fee'),
        );
        $rebate = $this->safe_string($order, 'rebated_fee');
        $fees[] = array(
            'currency' => $this->safe_currency_code($this->safe_string($order, 'rebated_fee_currency')),
            'cost' => $this->parse_number(Precise::string_neg($rebate)),
        );
        return $this->safe_order(array(
            'id' => $id,
            'clientOrderId' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $lastTradeTimestamp,
            'status' => $status,
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => $timeInForce,
            'postOnly' => null,
            'side' => $side,
            'price' => $price,
            'stopPrice' => null,
            'average' => null,
            'amount' => $amount,
            'cost' => $cost,
            'filled' => null,
            'remaining' => $remaining,
            'fee' => null,
            'fees' => $fees,
            'trades' => null,
            'info' => $order,
        ));
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrder() requires a $symbol argument');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'order_id' => $id,
            'currency_pair' => $market['id'],
        );
        $response = $this->privateSpotGetOrdersOrderId (array_merge($request, $params));
        return $this->parse_order($response, $market);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return $this->fetch_orders_helper('open', $symbol, $since, $limit, $params);
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return $this->fetch_orders_helper('finished', $symbol, $since, $limit, $params);
    }

    public function fetch_orders_helper($status, $symbol, $since, $limit, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'currency_pair' => $market['id'],
            'status' => $status,
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        if ($since !== null) {
            $request['start'] = (int) floor($since / 1000);
        }
        $response = $this->privateSpotGetOrders (array_merge($request, $params));
        return $this->parse_orders($response, $market, $since, $limit);
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        $this->load_markets();
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelOrders requires a $symbol parameter');
        }
        $market = $this->market($symbol);
        $request = array(
            'order_id' => $id,
            'currency_pair' => $market['id'],
        );
        $response = $this->privateSpotDeleteOrdersOrderId (array_merge($request, $params));
        return $this->parse_order($response);
    }

    public function transfer($code, $amount, $fromAccount, $toAccount, $params = array ()) {
        $this->load_markets();
        $currency = $this->currency($code);
        $accountsByType = $this->safe_value($this->options, 'accountsByType', array());
        $fromId = $this->safe_string($accountsByType, $fromAccount, $fromAccount);
        $toId = $this->safe_string($accountsByType, $toAccount, $toAccount);
        if ($fromId === null) {
            $keys = is_array($accountsByType) ? array_keys($accountsByType) : array();
            throw new ExchangeError($this->id . ' $fromAccount must be one of ' . implode(', ', $keys));
        }
        if ($toId === null) {
            $keys = is_array($accountsByType) ? array_keys($accountsByType) : array();
            throw new ExchangeError($this->id . ' $toAccount must be one of ' . implode(', ', $keys));
        }
        $truncated = $this->currency_to_precision($code, $amount);
        $request = array(
            'currency' => $currency['id'],
            'from' => $fromId,
            'to' => $toId,
            'amount' => $truncated,
        );
        if (($toId === 'futures') || ($toId === 'delivery')) {
            $request['settle'] = $currency['id'];
        }
        $response = $this->privateWalletPostTransfers (array_merge($request, $params));
        //
        // according to the docs
        //     {
        //       "$currency" => "BTC",
        //       "from" => "spot",
        //       "to" => "margin",
        //       "$amount" => "1",
        //       "currency_pair" => "BTC_USDT"
        //     }
        //
        // actual $response
        //  POST https://api.gateio.ws/api/v4/wallet/transfers 204 No Content
        //
        return array(
            'info' => $response,
            'from' => $fromId,
            'to' => $toId,
            'amount' => $truncated,
            'code' => $code,
        );
    }

    public function sign($path, $api = [], $method = 'GET', $params = array (), $headers = null, $body = null) {
        $authentication = $api[0]; // public, private
        $type = $api[1]; // spot, margin, future, delivery
        $query = $this->omit($params, $this->extract_params($path));
        $path = $this->implode_params($path, $params);
        $endPart = ($path === '' ? '' : '/' . $path);
        $entirePath = '/' . $type . $endPart;
        $url = $this->urls['api'][$authentication] . $entirePath;
        $queryString = '';
        if ($authentication === 'public') {
            $queryString = $this->urlencode($query);
            if ($query) {
                $url .= '?' . $queryString;
            }
        } else {
            if (($method === 'GET') || ($method === 'DELETE')) {
                $queryString = $this->urlencode($query);
                if ($query) {
                    $url .= '?' . $queryString;
                }
            } else {
                $body = $this->json($query);
            }
            $bodyPayload = ($body === null) ? '' : $body;
            $bodySignature = $this->hash($this->encode($bodyPayload), 'sha512');
            $timestamp = $this->seconds();
            $timestampString = (string) $timestamp;
            $signaturePath = '/api/v4' . $entirePath;
            $payloadArray = array( strtoupper($method), $signaturePath, $queryString, $bodySignature, $timestampString );
            $payload = implode('\n', $payloadArray);
            $signature = $this->hmac($this->encode($payload), $this->encode($this->secret), 'sha512');
            $headers = array(
                'KEY' => $this->apiKey,
                'Timestamp' => $timestampString,
                'SIGN' => $signature,
                'Content-Type' => 'application/json',
            );
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        $label = $this->safe_string($response, 'label');
        if ($label !== null) {
            $message = $this->safe_string($response, 'message');
            $Error = $this->safe_value($this->exceptions, $label, '\\ccxt\\ExchangeError');
            throw new \Exception($this->id . ' ' . $message);
        }
    }
}
